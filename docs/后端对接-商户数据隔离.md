# 后端对接说明：商户数据隔离（不同账号看到不同数据）

## 后端已实现（对接说明）

后端已按「商户隔离」改造：**GET /api/hotels** 使用 `optionalAuthMiddleware`，当请求头带 `Authorization: Bearer <token>` 且解析出 `req.user.role === 'merchant'` 时，只返回该商户的酒店（`user_id = req.user.id`，含待审核/已拒绝/已上线等全部状态）；未带 token 或非商户时仍返回所有已上线酒店。前端在商户登录后调用 GET /hotels 时**已自动在请求头带上** `Authorization: Bearer <登录返回的 token>`（见下方「前端在做什么」），无需再改。重启后端后，新注册商户登录应只能看到自己的酒店。

### 常见错误：`column h.user_id does not exist`

若 GET /hotels 报错 **column h.user_id does not exist**，说明后端在 SQL 里用了 `WHERE h.user_id = ?`，但表 `hotels` 中**没有 `user_id` 列**。需要后端/数据库做其一：

1. **给 `hotels` 表增加 `user_id` 列**（推荐）  
   - 类型与 `users.id` 一致（如 integer / bigint / uuid），可加外键关联 `users(id)`。  
   - 建表或 migration 示例：`ALTER TABLE hotels ADD COLUMN user_id INTEGER REFERENCES users(id);`  
   - 创建酒店时（POST /hotels）必须写入当前用户的 id 到 `user_id`；历史数据需按业务补全后再按 `user_id` 过滤。

2. **若已有别的列表示「所属商户」**（如 `merchant_id`、`owner_id`）  
   - 把查询里的 `h.user_id` 改成实际列名，并确保创建酒店时写入该字段。

前端无需修改；修好表结构或列名后，列表即可按用户正常返回。

---

## 现象（改造前）

PC 端用不同商户账号登录（如 rucheng、chenzhou），在「我的酒店」里看到的列表一样，说明**后端没有按当前登录用户区分数据**。

---

## 前端在做什么（已实现）

1. **登录**：调用 `POST /auth/login`，拿到响应后会保存 `data.user` 和 `data.token` 到浏览器本地。
2. **之后每次请求**：都会在请求头里带上 `Authorization: Bearer <token>`（只要有 token）。
3. **退出登录**：清空本地 user 和 token。

所以只要后端**登录时返回 token**，并且**业务接口根据 token 识别用户并过滤数据**，不同商户就会看到各自的数据。

---

## 后端需要做的三件事

### 1. 登录接口必须返回 token

**接口**：`POST /auth/login`  
**要求**：成功时在响应里返回一个**唯一标识当前会话/用户**的 token，供后续请求携带。

**推荐响应格式**（与 `api_pc.md` 一致）：

```json
{
  "code": 0,
  "message": "ok",
  "data": {
    "user": {
      "id": "2",
      "username": "rucheng",
      "role": "merchant"
    },
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
  }
}
```

- `data.user`：当前用户信息（id 必须能唯一区分不同商户）。
- `data.token`：字符串。前端会存起来，并在之后每个请求里带 `Authorization: Bearer <data.token>`。  
  若你们用别的字段名（如 `accessToken`、`access_token`），前端已做兼容，只要保证在 `data` 下即可。

**后端实现建议**：

- 登录成功后生成 JWT（或你们现有的 session token），把 **userId（或 merchantId）** 放进 payload。
- 把该 token 放在响应 `data.token` 里返回。

---

### 2. 业务接口根据 token 识别“当前用户”

**关键**：**不要**根据 IP、固定写死的用户 id、或“不鉴权默认某个用户”来查数据；**必须**从请求头里的 token 解析出“当前是哪个用户”，再用这个身份去查/写数据。

需要按用户隔离的接口包括（至少）：

| 接口 | 说明 |
|------|------|
| `GET /hotels` | 我的酒店列表：只返回**当前 token 对应用户**创建的酒店。 |
| `POST /hotels` | 创建酒店：把**当前 token 对应用户**记为该酒店的创建者/所属商户。 |
| `PUT /hotels/:id` | 更新酒店：只允许更新**当前用户**的酒店（或按你们权限规则）。 |
| `GET /hotels/:id` | 酒店详情：只允许查看**当前用户**的酒店（商户端场景下）。 |

**实现步骤建议**：

1. 写一个**鉴权中间件**（或拦截器）：
   - 从请求头读取 `Authorization: Bearer <token>`。
   - 校验 token 有效性（验签、过期等）。
   - 从 token 里解析出 **userId / merchantId**，挂到请求上下文（如 `req.userId`）。
2. 上述接口都经过该中间件，查询时用 `req.userId` 过滤：
   - 例如：`GET /hotels` → 只查 `where user_id = req.userId`（或你们的商户关联字段）。
   - 例如：`POST /hotels` → 写入时 `user_id = req.userId`。

这样 rucheng 和 chenzhou 的 token 里带的是不同的 userId，查到的列表和可操作的酒店自然就不同。

---

### 3. 不要“全局一份数据”或“固定 demo 用户”

- `/auth/me`（若已接）：应根据**当前请求的 token** 返回对应用户信息，**不要**无论谁请求都返回同一个固定用户（如固定返回 admin/demo_merchant）。
- 任何“我的 xxx”列表、创建/编辑接口，都不要：
  - 忽略 token；
  - 或写死一个 userId；
  - 或返回“全库数据、不按用户过滤”。

否则就会出现“不同商户看到相同内容”的问题。

---

## 如何自检（前后端一起看）

### 1. 看登录响应里有没有 token

- 浏览器打开开发者工具 → Network。
- 用 **rucheng** 登录，找到 `auth/login` 请求，看响应体：
  - 是否有 `data.token`（或 `data.accessToken` 等）？
  - 若没有，后端必须加上，这是第一步。

### 2. 看后续请求是否带了 Authorization

- 登录成功后，在 Network 里点开 **GET /hotels**（或任意业务接口）。
- 看 Request Headers 里是否有：  
  `Authorization: Bearer xxxxx`  
- 若没有，说明前端没拿到 token 或没存上，需要再确认登录响应格式；若有，说明前端已按约定带上了，问题在后端是否用这个 token 做鉴权和过滤。

### 3. 用两个账号对比

- 用 **rucheng** 登录 → 创建一家酒店 A → 记下「我的酒店」列表。
- **退出登录**，再用 **chenzhou** 登录。
- 看「我的酒店」列表：
  - 若只看到 chenzhou 自己创建的酒店（或空），说明按用户隔离已生效。
  - 若仍能看到 rucheng 创建的酒店 A，说明 GET /hotels（或相关接口）没有按 token 对应用户过滤，需要按上面第 2 点改后端。

---

## 和后端沟通时可以怎么说（直接复制即可）

> 我们前端已经做了：登录后保存后端返回的 user 和 token，之后所有请求都会带 `Authorization: Bearer <token>`。  
> 现在不同商户账号（如 rucheng、chenzhou）登录后看到的「我的酒店」还是一样的，说明要么登录没返回 token，要么返回了但 GET /hotels 等接口没有根据 token 里的用户 id 做过滤。  
> 请后端确认三件事：  
> 1. **POST /auth/login** 成功时，响应里是否有 **data.token**（或 accessToken），且该 token 能解析出当前用户的 id。  
> 2. **GET /hotels**（我的酒店列表）是否从请求头 `Authorization: Bearer <token>` 里取出 token，解析出当前用户 id，并只返回该用户创建的酒店。  
> 3. **POST /hotels**（创建酒店）是否把“当前 token 对应用户”记为该酒店的所属商户。  
> 接口约定和响应示例我们写在项目里的 `api_pc.md` 和 `docs/后端对接-商户数据隔离.md`，可以按里面的格式对接。

---

## 小结

| 问题 | 谁改 | 改什么 |
|------|------|--------|
| 登录响应里没有 token | 后端 | 登录成功时在 `data` 里返回 `token`（或 accessToken），且 token 中能解析出 userId。 |
| 请求头里没有 Authorization | 前端 | 已实现；若没有，检查登录响应里是否真有 token、key 是否被前端识别。 |
| 有 token 但列表仍一样 | 后端 | GET /hotels、POST /hotels 等必须根据 token 解析出的用户 id 做过滤/写入，不能忽略 token 或写死用户。 |

按上面三点和后端对齐后，不同商户账号就会看到各自的数据。
